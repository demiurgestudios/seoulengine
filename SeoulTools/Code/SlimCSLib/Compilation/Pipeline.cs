// Copyright (c) Demiurge Studios, Inc.
// 
// This source code is licensed under the MIT license.
// Full license details can be found in the LICENSE file
// in the root directory of this source tree.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Text;
using SlimCSLib.Generator;

namespace SlimCSLib.Compilation
{
	/// <summary>
	/// Wrapper around the full pipeline. Compiles .cs to syntax trees
	/// and passes through to Lua emit.
	/// </summary>
	public static class Pipeline
	{
		#region Private members
		// Manual import of memcmp for fast byte-for-byte comparison.
		[DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int memcmp(byte[] b1, byte[] b2, long count);
		
		struct TreeEntry : IComparable<TreeEntry>
		{
			public SyntaxTree m_Tree;
			public int m_Order;
			public string m_sName;
			public bool m_bHasExports;

			public int CompareTo(TreeEntry other)
			{
				int ret =  m_Order.CompareTo(other.m_Order);
				if (0 == ret) { return m_sName.CompareTo(other.m_sName); }
				return ret;
			}
		}

		struct TypeEntry : IComparable<TypeEntry>
		{
			public ITypeSymbol m_Type;
			public int m_Order;
			public string m_sName;
			public bool m_bHasStaticConstructor;
			public bool m_bIsExported;

			public int CompareTo(TypeEntry other)
			{
				int ret = m_Order.CompareTo(other.m_Order);
				if (0 == ret) { return m_sName.CompareTo(other.m_sName); }
				return ret;
			}
		}

		static void EmitFileLoader(
			CommandArgs args,
			SharedModel shared,
			SyntaxTree[] aSyntaxTrees,
			bool bSuppressGenerationFailureLogging)
		{
			// Special case - no files, no file loader.
			if (aSyntaxTrees.Length == 0)
			{
				return;
			}

			// Generates a file to load all files in the compiled program,
			// ordered to resolve dependencies.
			var sOutputFileName = Path.Combine(args.m_sOutDirectory, Constants.ksFileLibName);

			(TreeEntry[], TypeEntry[]) Sort()
			{
				var typeOrder = shared.TypeDepOrder;

				// Build a lookup table for syntax trees while
				// also constructing a list of types that need
				// to be constructed.
				var lookup = new Dictionary<SyntaxTree, (int, string, bool)>();
				var treeList = new List<TreeEntry>();
				var typeList = new List<TypeEntry>();
				foreach (var e in typeOrder)
				{
					var type = e.Key;
					var sName = shared.LookupOutputId(type);
					foreach (var syntaxNode in type.DeclaringSyntaxReferences)
					{
						var tree = syntaxNode.SyntaxTree;
						(int, string, bool) existing;
						if (lookup.TryGetValue(tree, out existing))
						{
							existing.Item1 = Utilities.Max(e.Value.Item1, existing.Item1);
						}
						else
						{
							existing.Item1 = e.Value.Item1;
							existing.Item2 = sName;
							existing.Item3 = !type.IsTopLevelChunkClass();
						}

						lookup[tree] = existing;
						typeList.Add(new TypeEntry()
						{
							m_Order = e.Value.Item1,
							m_sName = sName,
							m_Type = e.Key,
							m_bHasStaticConstructor = e.Value.Item2,
							m_bIsExported = existing.Item3,
						});
					}
				}

				// Now assemble trees.
				foreach (var tree in aSyntaxTrees)
				{
					// Skip any trees that don't have a lookup - these
					// will be generated files.
					(int, string, bool) e;
					if (!lookup.TryGetValue(tree, out e))
					{
						continue;
					}

					treeList.Add(new TreeEntry()
					{
						m_sName = e.Item2,
						m_Order = e.Item1,
						m_Tree = tree,
						m_bHasExports = e.Item3,
					});
				}

				// Finally, sort and return.
				treeList.Sort();
				typeList.Sort();
				return (treeList.ToArray(), typeList.ToArray());
			}

			// Get sorted data.
			(var trees, var types) = Sort();

			// Perform the emit.
			var sTempFileName = Path.GetTempFileName();
			using (var stream = File.Open(sTempFileName, FileMode.Create, FileAccess.Write, FileShare.Read))
			{
				using (var writer = new StreamWriter(stream, Encoding.ASCII))
				{
					writer.WriteLine("-- This file was generated by SlimCS. DO NOT MODIFY.");

					// Require.
					writer.WriteLine(); // Three sections of progress + any explicit in the code.
					writer.Write($"if __initprogresssteps__ then __initprogresssteps__({3 + shared.AdditionalInitProgress}) end -- For startup progress tracking.");
					writer.WriteLine();
					writer.Write("-- Concrete class file requires.");
					foreach (var entry in trees)
					{
						// Skip entries with no exports.
						if (!entry.m_bHasExports)
						{
							continue;
						}

						var syntaxTree = entry.m_Tree;
						var sInputPath = syntaxTree.FilePath;

						// Get output path.
						string sLuaOut;
						ResolveEmitPaths(
							args.m_sInDirectory,
							args.m_sOutDirectory,
							sInputPath,
							out sLuaOut);

						var sModule = Utilities.GetModulePath(sLuaOut, args.m_sOutDirectory);

						writer.WriteLine();
						writer.Write("require '");
						writer.Write(sModule);
						writer.Write("'");
					}
					writer.WriteLine();
					writer.Write("if __oninitprogress__ then __oninitprogress__() end");

					// Finish class definition.
					writer.WriteLine(); writer.WriteLine();
					writer.Write("-- Initialization of concrete classes.");
					foreach (var entry in types)
					{
						// Skip dummy roots, interfaces
						// and enums (which don't need class init completion).
						if (!entry.m_bIsExported ||
							entry.m_Type.TypeKind == TypeKind.Enum ||
							entry.m_Type.TypeKind == TypeKind.Interface)
						{
							continue;
						}

						writer.WriteLine();
						writer.Write("FinishClassTableInit(");
						writer.Write(entry.m_sName);
						writer.Write(")");
					}
					writer.WriteLine();
					writer.Write("if __oninitprogress__ then __oninitprogress__() end");

					// Run static constructors.
					writer.WriteLine(); writer.WriteLine();
					writer.Write("-- Execution of static constructors.");
					foreach (var entry in types)
					{
						// Skip duumy roots.
						if (!entry.m_bIsExported)
						{
							continue;
						}

						// Skip entries without a static constructor.
						if (!entry.m_bHasStaticConstructor)
						{
							continue;
						}

						writer.WriteLine();
						writer.Write(entry.m_sName);
						writer.Write(".cctor()");
					}
					writer.WriteLine();
					writer.Write("if __oninitprogress__ then __oninitprogress__() end");

					writer.Close();
				}
				stream.Close();
			}

			// Delete the target file.
			if (File.Exists(sOutputFileName))
			{
				File.Delete(sOutputFileName);
			}

			// Move the temp to the target.
			File.Move(sTempFileName, sOutputFileName);
		}

		static void EmitMain(
			CommandArgs args,
			SharedModel shared,
			SyntaxTree[] aSyntaxTrees,
			bool bSuppressGenerationFailureLogging)
		{
			// Special case - no files, no main.
			if (aSyntaxTrees.Length == 0)
			{
				return;
			}

			// Generates a file to load all files in the compiled program,
			// ordered to resolve dependencies.
			var sOutputFileName = Path.Combine(args.m_sOutDirectory, Constants.ksMainLibNameLua);

			// Perform the emit.
			var sTempFileName = Path.GetTempFileName();
			using (var stream = File.Open(sTempFileName, FileMode.Create, FileAccess.Write, FileShare.Read))
			{
				using (var writer = new StreamWriter(stream, Encoding.ASCII))
				{
					writer.Write(Constants.ksMainLibBody);
				}
			}

			// Delete the target file.
			if (File.Exists(sOutputFileName))
			{
				File.Delete(sOutputFileName);
			}

			// Move the temp to the target.
			File.Move(sTempFileName, sOutputFileName);
		}

		/// <summary>
		/// Internal utility, used by EmitLua().
		/// </summary>
		/// <param name="args">Configuration options for the generation.</param>
		/// <param name="syntaxTree">The syntax tree to emit.</param>
		/// <param name="semanticModel">Type lookup and additional info for an AST.</param>
		/// <returns>The body of the emitted .lua code.</returns>
		static byte[] EmitLua(
			CommandArgs args,
			Model model)
		{
			// Perform the emit.
			using (var stream = new MemoryStream())
			{
				using (var writer = new StreamWriter(stream, Encoding.ASCII))
				{
					using (var visitor = new Generator.Visitor(args, model, writer))
					{
						// No statements - handled by the Visitor constructor.
					}
					writer.Close();
				}
				stream.Close();

				return stream.ToArray();
			}
		}

		/// <summary>
		/// Given trees converted to Lua trees, write the output
		/// to the target directory.
		/// </summary>
		/// <param name="stdOut">Equivalent to stdOut for any builder status.</param>
		/// <param name="stdErr">Equivalent to stdErr for any builder status.</param>
		/// <param name="args">Configuration of all stages of the compiler.</param>
		/// <param name="shared">Semantic model that describes the entire compilation.</param>
		/// <param name="aSyntaxTrees">Full set of parsed syntax trees.</param>
		/// <param name="bSuppressGenerationFailureLogging">If true, no logging to stdErr or stdOut will occur.</param>
		static void EmitLua(
			WriteLineHandler stdOut,
			WriteLineHandler stdErr,
			CommandArgs args,
			SharedModel shared,
			SyntaxTree[] aSyntaxTrees,
			bool bSuppressGenerationFailureLogging)
		{
			// Harness file to skip during generation.
			// TODO: Don't hard code this.
			var sSkipFileName = (args.m_bUnitTest ? "TestHarness.cs" : "SlimCS.cs");

			// Storage and tracking.
			int iSuccessCount = 0;
			bool bSkippedSlimCSSystemLib = false;

			// Caught exception tracking.
			var exceptions = new ConcurrentBag<Exception>();

			// Allocate an array for output.
			var asOutput = new(string, byte[])[aSyntaxTrees.Length];
			try
			{
				int iOutputSlots = 0;

				// Parallel writing.
				Parallel.ForEach(
					aSyntaxTrees,
					args.m_ParallelOptions,
					(syntaxTree, loopState) =>
				{
					try
					{
					   var sInputPath = syntaxTree.FilePath;

						// TODO: Don't hard code this.
						if (Path.GetFileName(sInputPath) == sSkipFileName)
						{
							bSkippedSlimCSSystemLib = true;
							return;
						}

						// Get output path.
						string sOutputFileName;
						ResolveEmitPaths(
							args.m_sInDirectory,
							args.m_sOutDirectory,
							sInputPath,
							out sOutputFileName);

						// Allocate a slot for ourselves.
						int iOutputSlot = Interlocked.Increment(ref iOutputSlots) - 1;

						// Perform the actual emit operation.
						var aData = EmitLua(args, new Model(shared, syntaxTree));

						// Store.
						asOutput[iOutputSlot] = (sOutputFileName, aData);

						// Tracking.
						Interlocked.Increment(ref iSuccessCount);
					}
					catch (Exception e)
					{
						exceptions.Add(e);
						if (!bSuppressGenerationFailureLogging)
						{
							stdErr(e.Message);
						}
					}
				});

				// Now commit the files to their output location.
				foreach ((var sOutputFileName, var aData) in asOutput)
				{
					// Skip files not emitted - special case.
					if (string.IsNullOrEmpty(sOutputFileName))
					{
						continue;
					}

					// Delete the target file.
					if (File.Exists(sOutputFileName))
					{
						// TODO: Reading and checking to avoid the write
						// significantly speeds up the operation overall, which doesn't
						// make sense to me. Maybe WriteAll() performs an fsync()? Otherwise,
						// in theory, the write should all go to a write cache, whereas the
						// read is more likely to hit disk...
						//
						// In any case, I'm leaving this here as my midterm plan is to add
						// caching of file state to the Service, so this operation will then
						// all be in memory and this I/O mystery will be a moot point.
						var info = new FileInfo(sOutputFileName);
						if (info.Length == (long)aData.Length)
						{
							var aExisting = File.ReadAllBytes(sOutputFileName);
							if (aData.Length == aExisting.Length && memcmp(aData, aExisting, aData.Length) == 0)
							{
								continue;
							}
						}

						File.Delete(sOutputFileName);
					}
					// Otherwise, make sure the directory exists for the file.
					else
					{
						Directory.CreateDirectory(Path.GetDirectoryName(sOutputFileName));
					}

					// Move the temp to the target.
					File.WriteAllBytes(sOutputFileName, aData);
				}
			}
			finally
			{
				// Exit immediately on any failure.
				if (!exceptions.IsEmpty)
				{
					Exception e = null;
					exceptions.TryPeek(out e);
					throw e;
				}
				if ((bSkippedSlimCSSystemLib && iSuccessCount + 1 < aSyntaxTrees.Length) ||
					(!bSkippedSlimCSSystemLib && iSuccessCount < aSyntaxTrees.Length))
				{
					throw new Exception("Some output files were generated successfully.");
				}
			}
		}

		/// <summary>
		/// Find all files in sInDirectory and parse into
		/// C# syntax trees.
		/// </summary>
		/// <param name="stdOut">Equivalent to stdOut for any builder status.</param>
		/// <param name="stdErr">Equivalent to stdErr for any builder status.</param>
		/// <param name="args">Arguments passed to the compiler.</param>
		/// <returns>The parsed .cs files.</returns>
		static SyntaxTree[] ParseCSharp(
			WriteLineHandler stdOut,
			WriteLineHandler stdErr,
			CommandArgs args)
		{
			// Get the files to parse.
			var asFiles = Directory.GetFiles(args.m_sInDirectory, "*.cs", SearchOption.AllDirectories);

			// Storage and tracking.
			var aReturn = new SyntaxTree[asFiles.Length];
			int iSuccessCount = 0;

			// Caught exception tracking.
			var exceptions = new ConcurrentBag<Exception>();

			// Parallel parsing.
			var parseOptions = new CSharpParseOptions(
				 LanguageVersion.Latest,
				 DocumentationMode.Parse,
				 SourceCodeKind.Regular,
				 args.m_ConditionalCompilationSymbols);
			Parallel.ForEach(asFiles, args.m_ParallelOptions, (sFile, loopState) =>
			{
				try
				{
					var sBody = File.ReadAllText(sFile);
					var syntaxTree = CSharpSyntaxTree.ParseText(
						sBody,
						parseOptions,
						sFile);

					int iIndex = Interlocked.Increment(ref iSuccessCount) - 1;
					aReturn[iIndex] = syntaxTree;
				}
				catch (Exception e)
				{
					exceptions.Add(e);
					stdErr(e.Message);
				}
			});

			if (!exceptions.IsEmpty)
			{
				Exception e = null;
				exceptions.TryPeek(out e);
				throw e;
			}
			if (iSuccessCount < aReturn.Length)
			{
				throw new Exception("Some input files were not parsed successfull.y");
			}

			return aReturn;
		}

		/// <summary>
		/// Given input/output directories and an input .cs filename,
		/// output the absolute path to the output .lua file for
		/// writing as well as the relative module specifier to be used
		/// to initialize that file at runtime.
		/// </summary>
		/// <param name="sInDirectory">Path to the base input directory.</param>
		/// <param name="sOutDirectory">Path to the output directory for writing.</param>
		/// <param name="sInputFileName">Path to the input .cs file we're resolving.</param>
		/// <param name="rsOutputFileName">Path for output write.</param>
		static void ResolveEmitPaths(
			string sInDirectory,
			string sOutDirectory,
			string sInputFileName,
			out string rsOutputFileName)
		{
			var sRelativePath = FileUtility.PathRelativeTo(sInDirectory, sInputFileName);

			rsOutputFileName = FileUtility.NormalizePath(
				Path.Combine(sOutDirectory, Path.ChangeExtension(sRelativePath, ".lua")));
		}
		#endregion

		public delegate void WriteLineHandler(string s);

		public static ConcurrentBag<Exception> Analyze(
			CommandArgs args,
			SharedModel shared,
			ImmutableArray<SyntaxTree> aSyntaxTrees)
		{
			// Caught exception tracking.
			var exceptions = new ConcurrentBag<Exception>();

			// Parallel writing.
			Parallel.ForEach(
				aSyntaxTrees,
				new ParallelOptions() { MaxDegreeOfParallelism = Environment.ProcessorCount },
				(syntaxTree, loopState) =>
				{
					// TODO: Don't hard code this.
					if (Path.GetFileName(syntaxTree.FilePath) == "SlimCS.cs")
					{
						return;
					}

					try
					{
						var model = new Model(shared, syntaxTree);

						// We just discard the output for analysis.
						using (var stream = new MemoryStream())
						{
							using (var writer = new StreamWriter(stream, Encoding.ASCII))
							{
								using (var visitor = new Generator.Visitor(args, model, writer))
								{
									// No statements - handled by the Visitor constructor.
								}
								writer.Close();
							}
							stream.Close();
						}
					}
					catch (Exception e)
					{
						exceptions.Add(e);
					}
				});

			return exceptions;
		}

		/// <summary>
		/// Convenience - allows the CL to avoid dependencies on external Roslyn libraries.
		/// </summary>
		public static void ClBuild(
			WriteLineHandler stdOut,
			WriteLineHandler stdErr,
			CommandArgs args,
			bool bSuppressGenerationFailureLogging,
			bool bTesting)
		{
			Build(stdOut, stdErr, args, bSuppressGenerationFailureLogging, bTesting);
		}

		/// <summary>
		/// Handles the full processing. Reads all .cs files in sInDirectory,
		/// converts to equivalent .lua output, and writes the results to
		/// sOutDirectory.
		/// </summary>
		/// <param name="stdOut">Equivalent to stdOut for any builder status.</param>
		/// <param name="stdErr">Equivalent to stdErr for any builder status.</param>
		/// <param name="args">Configuration of the compiler.</param>
		/// <param name="bSuppressGenerationFailureLogging">Don't log on failure. Used for unit tests.</param>
		/// <param name="bTesting">If true, the full mscorlib is used. Otherwise, SlimCSCorlib is used.</param>
		/// <returns>The generated CSharp ASTs, for possible unit testing.</returns>
		public static (SyntaxTree[], SharedModel) Build(
			WriteLineHandler stdOut,
			WriteLineHandler stdErr,
			CommandArgs args,
			bool bSuppressGenerationFailureLogging,
			bool bTesting)
		{
			AutoResetEvent evt = null;
			string sError = null;

			try
			{
				var overallTimer = System.Diagnostics.Stopwatch.StartNew();
				var timer = System.Diagnostics.Stopwatch.StartNew();

				// Parse.
				var aSyntaxTrees = ParseCSharp(stdOut, stdErr, args);

				if (args.m_bTiming) { stdOut($"Syntax Trees: {timer.Elapsed.TotalSeconds:0.00} s"); timer.Restart(); }

				// Instantiation a compilation unit.
				var compilation = Compiler.CompileForCodeGen(args, aSyntaxTrees, bTesting);

				if (args.m_bTiming) { stdOut($"Compilation Create: {timer.Elapsed.TotalSeconds:0.00} s"); timer.Restart(); }

				// If validating, start that now while we're emiting.
				if (args.m_bValidate)
				{
					evt = new AutoResetEvent(false);

					// Kick off the validation step on a separate thread.
					if (!ThreadPool.QueueUserWorkItem((object state) =>
					{
						try
						{
							var diag = compilation.GetDiagnostics();
							if (!diag.IsEmpty)
							{
								sError = string.Join(Environment.NewLine, diag);
							}
						}
						catch (Exception e)
						{
							sError = e.ToString();
						}
						finally
						{
							evt.Set();
						}
					}))
					{
						sError = "failed starting validation compile.";
						evt.Set();
					}
				}

				try
				{
					// Wrap the unit in our shared model.
					var shared = new SharedModel(args, compilation);

					if (args.m_bTiming) { stdOut($"SharedModel Create: {timer.Elapsed.TotalSeconds:0.00} s"); timer.Restart(); }

					// Now emit the output as .lua files.
					EmitLua(stdOut, stdErr, args, shared, aSyntaxTrees, bSuppressGenerationFailureLogging);
					EmitFileLoader(args, shared, aSyntaxTrees, bSuppressGenerationFailureLogging);

					// Main is only emitted if SlimCSMain.cs does not exist in the input.
					if (!File.Exists(Path.Combine(args.m_sInDirectory, Constants.ksMainLibNameCS)))
					{
						EmitMain(args, shared, aSyntaxTrees, bSuppressGenerationFailureLogging);
					}

					if (args.m_bTiming) { stdOut($"Lua Emit: {timer.Elapsed.TotalSeconds:0.00} s"); timer.Restart(); }

					// Final timings and return values.
					if (args.m_bTiming) { stdOut($"Validation Emit Wait: {timer.Elapsed.TotalSeconds:0.00} s"); timer.Restart(); }
					if (args.m_bTiming) { stdOut($"Total Compilation Time: {overallTimer.Elapsed.TotalSeconds:0.00} s"); }
					return (aSyntaxTrees, shared);
				}
				catch (Exception)
				{
					// Finish validation if running.
					if (null != evt)
					{
						// Wait for validation.
						evt.WaitOne();
						evt = null;
					}

					// Preference validation.
					if (!string.IsNullOrEmpty(sError))
					{
						var sToThrow = sError;
						sError = null;
						throw new CSharpCompilationException(sToThrow);
					}

					// Otherwise, rethrow.
					throw;
				}
			}
			finally
			{
				// Finish validation if running.
				if (null != evt)
				{
					// Wait for validation.
					evt.WaitOne();
					evt = null;
				}

				// Throw on validation failure.
				if (!string.IsNullOrEmpty(sError))
				{
					var sToThrow = sError;
					sError = null;
					throw new CSharpCompilationException(sToThrow);
				}
			}
		}
	}
}
