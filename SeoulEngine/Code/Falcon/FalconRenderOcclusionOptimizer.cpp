/**
 * \file FalconRenderOcclusionOptimizer.cpp
 * This render optimizer consumes the flattened scene
 * graph (generated by the Poser) and optimizes it by
 * - use a software coverage rasterizer to detect
 *   occlusion and avoid submission of hidden nodes.
 *
 * Copyright (c) Demiurge Studios, Inc.
 * 
 * This source code is licensed under the MIT license.
 * Full license details can be found in the LICENSE file
 * in the root directory of this source tree.
 */

#include "FalconClipper.h"
#include "FalconRenderCommand.h"
#include "FalconRenderOcclusionOptimizer.h"

namespace Seoul::Falcon
{

namespace Render
{

OcclusionOptimizer::OcclusionOptimizer()
	: m_aBuckets()
	, m_vbOccluded()
{
}

OcclusionOptimizer::~OcclusionOptimizer()
{
}

/**
 * Apply occlusion rectangles to remove draw commands that are not
 * visible/completely occluded.
 */
void OcclusionOptimizer::Optimize(Render::CommandBuffer& rBuffer)
{
	UInt32 const uOrigSize = rBuffer.GetBufferSize();

	// Size out the occluded tracking.
	m_vbOccluded.Clear();
	m_vbOccluded.Resize(uOrigSize);

	// Reset buckets.
	for (auto& e : m_aBuckets)
	{
		e.Reset();
	}

	// Track total occluded count.
	UInt32 uOccluded = 0u;

	// Two different loops - one if any scissor rectangles are
	// used, a second for the default case. We need to
	// walk the list twice if there are scissors, to figure
	// out what scissors apply to what shapes and then use
	// that to further clip the testers and occluders.
	if (rBuffer.GetRectangles() > 0u)
	{
		// First, fill out scissors. Must be done front-to-back
		// (which follows back-to-front render order).
		m_vScissors.Clear();
		m_vScissors.Resize(uOrigSize);
		{
			Int16 iScissor = -1;
			for (UInt32 i = 0u; i < uOrigSize; ++i)
			{
				auto const& cmd = *(rBuffer.Begin() + i);

				// Handle scissor changes.
				if ((UInt16)CommandType::kBeginScissorClip == cmd.m_uType)
				{
					// Always an active scissor.
					iScissor = (Int16)cmd.m_u;
				}
				else if ((UInt16)CommandType::kEndScissorClip == cmd.m_uType)
				{
					// Only active if the associated rectangle
					// is non-zero.
					auto const& rect = rBuffer.GetRectangle(cmd.m_u);
					if (rect.m_fLeft == rect.m_fRight) { iScissor = -1; }
					else { iScissor = (Int16)cmd.m_u; }
				}

				// Done, we have a scissor for this element.
				m_vScissors[i] = iScissor;
			}
		}

		// Walk the list back-to-front (which will observe pose instances
		// in their front-to-back render order).
		Rectangle scissor;
		Rectangle worldRectangle;
		Rectangle worldOcclusionRectangle;
		for (Int32 i = (Int32)uOrigSize - 1; i >= 0; --i)
		{
			auto const& cmd = *(rBuffer.Begin() + i);
			if ((UInt16)CommandType::kPose != cmd.m_uType)
			{
				continue;
			}

			// Get the pose instance.
			auto const& pose = rBuffer.GetPose(cmd.m_u);
			worldRectangle = pose.m_WorldRectangle;

			// Clip the rectangle if a scissor is active.
			auto const iScissor = m_vScissors[i];
			auto const bHasScissor = (iScissor >= 0);
			if (bHasScissor)
			{
				scissor = rBuffer.GetRectangle((UInt16)iScissor);
				worldRectangle.m_fLeft = Max(worldRectangle.m_fLeft, scissor.m_fLeft);
				worldRectangle.m_fRight = Min(worldRectangle.m_fRight, scissor.m_fRight);
				worldRectangle.m_fTop = Max(worldRectangle.m_fTop, scissor.m_fTop);
				worldRectangle.m_fBottom = Min(worldRectangle.m_fBottom, scissor.m_fBottom);
			}

			// Now check if the posable is occluded.
			if (IsOccluded(worldRectangle))
			{
				m_vbOccluded[i] = true;
				++uOccluded;
			}
			// Otherwise, potentially add the posable's occlusion
			// rectangle.
			else if (!pose.m_WorldOcclusionRectangle.IsZero())
			{
				// Rectangle clipping fails if the clipper is complex,
				// so don't add the occlusion rectangle
				worldOcclusionRectangle = pose.m_WorldOcclusionRectangle;

				// Clip the occluder if we have an active scissor clip.
				if (bHasScissor)
				{
					worldOcclusionRectangle.m_fLeft = Max(worldOcclusionRectangle.m_fLeft, scissor.m_fLeft);
					worldOcclusionRectangle.m_fRight = Min(worldOcclusionRectangle.m_fRight, scissor.m_fRight);
					worldOcclusionRectangle.m_fTop = Max(worldOcclusionRectangle.m_fTop, scissor.m_fTop);
					worldOcclusionRectangle.m_fBottom = Min(worldOcclusionRectangle.m_fBottom, scissor.m_fBottom);
				}

				MergeOccluder(worldOcclusionRectangle);
			}
		}
	}
	else
	{
		// Walk the list back-to-front (which will observe pose instances
		// in their front-to-back render order).
		for (Int32 i = (Int32)uOrigSize - 1; i >= 0; --i)
		{
			auto const& cmd = *(rBuffer.Begin() + i);
			if ((UInt16)CommandType::kPose != cmd.m_uType)
			{
				continue;
			}

			// Get the pose instance.
			auto const& pose = rBuffer.GetPose(cmd.m_u);
			auto const& worldRectangle = pose.m_WorldRectangle;

			// Now check if the posable is occluded.
			if (IsOccluded(worldRectangle))
			{
				m_vbOccluded[i] = true;
				++uOccluded;
			}
			// Otherwise, potentially add the posable's occlusion
			// rectangle.
			else if (!pose.m_WorldOcclusionRectangle.IsZero())
			{
				// Rectangle clipping fails if the clipper is complex,
				// so don't add the occlusion rectangle
				auto const& rect = pose.m_WorldOcclusionRectangle;
				MergeOccluder(rect);
			}
		}
	}

	// Now if any are occluded, rebuild the list and exclude those occluded
	if (0u == uOccluded)
	{
		return;
	}

	CommandBuffer::Buffer v;
	v.Reserve(uOrigSize - uOccluded);
	for (UInt32 i = 0u; i < uOrigSize; ++i)
	{
		if (!m_vbOccluded[i])
		{
			v.PushBack(*(rBuffer.Begin() + i));
		}
	}

	rBuffer.SwapBuffer(v);
}

// TODO: We currently only check rectangles against
// single occluded rectangles. This will not catch cases
// where multiple occluders *together* fully occlude
// a visible rectangle.

/**
 * Check if a visible rectangle is occluded by the current
 * occlusion state or not.
 */
Bool OcclusionOptimizer::IsOccluded(const Rectangle& rect) const
{
	for (auto const& e : m_aBuckets)
	{
		// The accumualted rectangle must contain the rect, or it
		// is not possible for any of the member rectangles
		// to occlude the rect.
		if (!Contains(e.m_Merged, rect))
		{
			continue;
		}

		auto const& v = e.m_vRectangles;
		for (auto const& r : v)
		{
			if (Contains(r, rect))
			{
				return true;
			}
		}
	}

	return false;
}

/**
 * Add the given rectangle to the occlusion set.
 * Will be rejected if it is fully occluded
 * by an existing occluder.
 */
void OcclusionOptimizer::MergeOccluder(const Rectangle& rect)
{
	// Pick the best bucket based on count and intersection.
	auto iBest = m_aBuckets.End();
	UInt32 uBestCount = UIntMax;
	for (auto iBucket = m_aBuckets.Begin(); m_aBuckets.End() != iBucket; ++iBucket)
	{
		// With no intersections, prefer even buckets.
		UInt32 const uCount = iBucket->m_vRectangles.GetSize();
		if (uCount < uBestCount)
		{
			iBest = iBucket;
			uBestCount = uCount;
		}
		// Otherwise, break immediately on an overlap.
		else if (Intersects(iBucket->m_Merged, rect))
		{
			iBest = iBucket;
			break;
		}
	}

	iBest->m_Merged = Rectangle::Merge(iBest->m_Merged, rect);
	iBest->m_vRectangles.PushBack(rect);
}

} // namespace Render

} // namespace Seoul::Falcon
