/**
 * \file FalconRenderBatchOptimizer.cpp
 * This render optimizer consumes the flattened scene
 * graph (generated by the Poser) and optimizes it by
 * - re-ordering viable draw calls (those that do not
 *   overlap) to maximize batch sizes.
 *
 * Copyright (c) Demiurge Studios, Inc.
 * 
 * This source code is licensed under the MIT license.
 * Full license details can be found in the LICENSE file
 * in the root directory of this source tree.
 */

#include "FalconRenderBatchOptimizer.h"
#include "FalconRenderCommand.h"

namespace Seoul::Falcon
{

namespace Render
{

BatchOptimizer::BatchOptimizer()
	: m_vBuffer()
	, m_vLanes()
	, m_iLanes(0)
{
}

BatchOptimizer::~BatchOptimizer()
{
	SafeDeleteVector(m_vLanes);
}

/**
 * Reorder and prune the command stream in rBuffer
 * to maximize batch sizes and reduce draw call
 * overhead.
 */
void BatchOptimizer::Optimize(Falcon::Render::CommandBuffer& rBuffer)
{
	// Iterate over the input buffer, then distribute into
	// lanes.
	{
		auto const iBegin = rBuffer.Begin();
		auto const iEnd = rBuffer.End();
		for (auto i = iBegin; iEnd != i; ++i)
		{
			switch ((CommandType)i->m_uType)
			{
				// Insert a Pose command. This will be
				// distributed into a lane for reordering
				// to maximize batch sizes.
			case CommandType::kPose:
				AddPose(rBuffer, *i);
				break;

				// All other command types, for now, force
				// an immediate flush of pending lanes. Fortunately,
				// most of these are developer only. kBegin/kEnd
				// are only emitted at the very end and beginning
				// of draw command issue. So, in practice, the
				// only events that will breakup the command stream
				// are kViewportChange and kViewProjectionChange,
				// and the various special cases like planar shadows
				// or scissor clip.
			case CommandType::kBeginInputVisualization:
			case CommandType::kBeginPlanarShadows:
			case CommandType::kBeginScissorClip:
			case CommandType::kCustomDraw:
			case CommandType::kEndInputVisualization:
			case CommandType::kEndPlanarShadows:
			case CommandType::kEndScissorClip:
			case CommandType::kPoseInputVisualization:
			case CommandType::kUnknown:
			case CommandType::kViewportChange:
			case CommandType::kViewProjectionChange:
			case CommandType::kWorldCullChange:
			default:
				Flush();
				m_vBuffer.PushBack(*i);
				break;
			};
		}
	}

	// Final flush of lanes.
	Flush();

	// Sanity check - we never remove commands, only reorder, so
	// sizes should be exactly the same.
	SEOUL_ASSERT(rBuffer.GetBufferSize() == m_vBuffer.GetSize());

	// Replace the output with the buffer we constructed.
	rBuffer.SwapBuffer(m_vBuffer);

	// Now clear our intermediate buffers.
	m_vBuffer.Clear();
	m_iLanes = 0;
}

/**
 * Insert a pose command into our lane structure. This
 * can potentially trigger a flush of one or more
 * overlapping lanes.
 *
 * A lane is a set of draw calls that share the same
 * texture. We can accumulate lanes and submit them
 * as batches, without creating a render error,
 * as long as the lanes do not overlap (their world
 * rectangles do not intersect).
 */
void BatchOptimizer::AddPose(
	const CommandBuffer& buffer,
	const Command& cmd)
{
	auto const& pose = buffer.GetPose(cmd.m_u);

	// Algorithm is as follows:
	// - lanes represent batches in back-to-front order (we must flush
	//   lanes from 0 to n to get correct rendering).
	// - when inserting a pose:
	//   - search for its lane from the end to the beginning:
	//     - if we intersect a lane prior to finding a home lane,
	//       we must generate a new lane (we're possibly and deliberately
	//       splitting a batch, if a home lane already exists for the pose).
	//     - otherwise, we stop once we find a proper home lane.

	Int32 iInsert = -1;
	for (Int32 i = (m_iLanes - 1); i >= 0; --i)
	{
		auto const& lane = *m_vLanes[i];

		// We've found a home lane for the instance, we're done. Note that
		// an instance can have multiple possible home lanes (multiple lanes
		// can have the same texture). The lane at the highest number
		// is always the correct one, since our input is back-to-front,
		// and our lanes are ordered back-to-front.
		if (lane.m_pTexture == pose.m_TextureReference.m_pTexture.GetPtr() &&
			lane.m_eFeature == pose.m_eFeature)
		{
			// Reuse this home lane for the command.
			iInsert = i;
			break;
		}
		// Otherwise, if the new pose command intersects, we have two options:
		// - pull the existing home lane forward to be at i, then
		//   insert into it.
		// - generate a new home lane (break the batch).
		else if (lane.Intersects(buffer, pose.m_WorldRectangle))
		{
			// Search for an existing home lane, all the way to 0.
			Int32 iExistingHome = -1;
			for (Int32 j = (i - 1); j >= 0; --j)
			{
				auto const& existingLane = *m_vLanes[j];
				if (existingLane.m_pTexture == pose.m_TextureReference.m_pTexture.GetPtr() &&
					existingLane.m_eFeature == pose.m_eFeature)
				{
					iExistingHome = j;
					break;
				}
			}

			// No existing home, give up now.
			if (iExistingHome < 0)
			{
				// Must insert a new lane for this command.
				iInsert = -1;
				break;
			}

			// Now try to move the existing lane to i.
			// If this succeeds, we can use the existing, otherwise
			// we insert into the end.
			iInsert = MoveLane(buffer, iExistingHome, i) ? i : -1;

			// In all cases, now done.
			break;
		}
	}

	// Add a new lane if necessary.
	if (iInsert < 0)
	{
		// Out of space, need to allocate an entirely new lane.
		if (m_iLanes >= (Int32)m_vLanes.GetSize())
		{
			m_vLanes.PushBack(SEOUL_NEW(MemoryBudgets::Falcon) Lane);
		}

		// Insert and acquire.
		iInsert = m_iLanes++;
		auto& lane = *m_vLanes[iInsert];

		// Setup the initial lane state.
		lane.m_pTexture = pose.m_TextureReference.m_pTexture.GetPtr();
		lane.m_eFeature = pose.m_eFeature;
		lane.m_Rect = Rectangle::InverseMax();
		lane.m_vBuffer.Clear();
	}

	// Now merge the entry.
	{
		auto& lane = *m_vLanes[iInsert];
		lane.m_Rect = Rectangle::Merge(lane.m_Rect, pose.m_WorldRectangle);
		lane.m_vBuffer.PushBack(cmd);
	}
}

/**
 * Commit all pending lanes to the output buffer
 * being generated.
 */
void BatchOptimizer::Flush()
{
	// Enumerate active lanes and append to the
	// output buffer.
	for (Int32 i = 0; i < m_iLanes; ++i)
	{
		m_vBuffer.Append(m_vLanes[i]->m_vBuffer);
	}

	// Clear all lanes.
	m_iLanes = 0;
}

/**
 * Attempt to move a lane back in the draw order.
 * To succeed, the entire lane must not intersect
 * any lane between it and its target position.
 */
Bool BatchOptimizer::MoveLane(
	const CommandBuffer& buffer,
	Int32 iFrom,
	Int32 iTo)
{
	auto& laneA = *m_vLanes[iFrom];

	// Sanity check.
	SEOUL_ASSERT(iTo <= m_iLanes);

	// Check against all lanes from (iFrom + 1) up
	// to and including iTo.
	for (Int32 i = (iFrom + 1); i <= iTo; ++i)
	{
		auto const& laneB = *m_vLanes[i];
		if (laneB.Intersects(buffer, laneA))
		{
			// Failure.
			return false;
		}
	}

	// Can move, do so now.
	auto pExisting = m_vLanes[iFrom];
	for (Int32 i = iFrom; i < iTo; ++i)
	{
		m_vLanes[i] = m_vLanes[i+1];
	}
	m_vLanes[iTo] = pExisting;

	// Done, successfully moved and updated.
	return true;
}

/**
 * Scan this lane for an intersection, return
 * true if one was found.
 */
Bool BatchOptimizer::Lane::Intersects(const CommandBuffer& buffer, const Falcon::Rectangle& rect) const
{
	// No intersection with the entire lane.
	if (!Falcon::Intersects(m_Rect, rect))
	{
		return false;
	}

	// Check all rectangles in the lane.
	auto const iBegin = m_vBuffer.Begin();
	auto const iEnd = m_vBuffer.End();
	for (auto iLane = iBegin; iEnd != iLane; ++iLane)
	{
		auto const& pose = buffer.GetPose(iLane->m_u);

		// Intersection, return true.
		if (Falcon::Intersects(pose.m_WorldRectangle, rect))
		{
			return true;
		}
	}

	// No intersection.
	return false;
}

// Scan this lane for an intersection against laneB.
Bool BatchOptimizer::Lane::Intersects(const CommandBuffer& buffer, const Lane& b) const
{
	// Early out.
	if (!Falcon::Intersects(m_Rect, b.m_Rect))
	{
		return false;
	}

	// Check all rectangles in the lane.
	auto const iBegin = m_vBuffer.Begin();
	auto const iEnd = m_vBuffer.End();
	for (auto iLane = iBegin; iEnd != iLane; ++iLane)
	{
		auto const& pose = buffer.GetPose(iLane->m_u);

		// Intersection, return true.
		if (b.Intersects(buffer, pose.m_WorldRectangle))
		{
			return true;
		}
	}

	// No intersection.
	return false;
}

} // namespace Render

} // namespace Seoul::Falcon
